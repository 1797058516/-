---
description: 第七章开始
---

# C++ QT设计模式\_2

心得

最重要的就是QObject这个类，这是QT对象模型的核心类。要怎么理解这个类，一开始书上内容提到什么一个qobject最多只能有一个父对象等等这些限制，看的云里雾里，然后去看qobject的[源代码](https://code.woboq.org/qt5/qtbase/src/corelib/kernel/qobject.h.html#QObject)，光这个类的声明就300多行还不包括函数实现。然后去[QT官网看官网解释QObject](https://doc.qt.io/qt-5/qobject.html)。在推荐一个[知乎作者](https://www.zhihu.com/people/renlifei/columns)写了一个QT专栏还不错。笔记主要来源书中。

QObject设计到的设计模式思想就是组合模式和观察者模式。

## 库与设计模式

库是一种代码，它按照可复用的方式组织。

包含头文件时，其工作是由链接器在链编过程完成。

库是一个文件，它包含多个编译后文件（目标文件），将多个目标文件集成在一个库中，能够显著提速链接过程。

在现代编程技术中，代码复用具有最高优先级，人工成本很贵的。

所有就软件都是基于块构建的，块本身也可以看成是一个软件，几乎没有从头开始进行应用设计的，因为这样做是将程序员时间浪费在重复设计和实现那些公认非常优秀的模块。

框架通常被用来创建图形化应用、数据库应用或者其他复杂软件。

为了实现框架，可以采用设计模式。用设计模式进行开发涉及寻找合适的对象和可能的层次。

设计模式的三种类别：1.创建模式。2.结构模式。3.行为模式。

结构模式描述如何组织对象并连接它们；行为模式描述如何组织代码；创建模式描述如何组织那些用于管理对象创建的代码。

设计模式是”在特定环境下用于_解决_某类设计_问题_的类与对象间**通信**关系的描述。

#### 序列化器模式：QTextStream和QDataStream

序列化器是一种负责读取或者写入对象的对象。[什么是序列化](https://zhuanlan.zhihu.com/p/35361535)

QTextStream和QDataStream这些类是用序列化器模式实现的被用于C++和QT。

## QObject，QApplication，信号和槽

QObject是qt库中许多重要类的基类，eg：QWidget、QEvent、QLayout等等

我们会把qobject派生类的对象都看作是一个qobject对象。

一个qobject可以有一个父对象和一些子对象，这是组合模式的另一种实现方式。

它可以使用信号和槽，即观察者模式的一种实现，与其他qobject通信。

qobject使基于事件的编程成为可能。

qobject没有公有的复制构造函数或复制赋值运算符。qobject利用一个宏定义，它显示的确保任何qobject都**不能被复制。**

qobject也不是设计用于复制的，通常来说qobject会用来代表具有唯一身份的对象。这种不带复制构造函数的后果就是永远无法通过值传递方式向函数传递qobject。

显示构造函数：QObject（及其派生类）的单参数构造函数应当予以显式(explicit)声明，以避免意外的隐 式转换的发生。

每个object最多只能有一个父qobject，但是可以拥有任意数量的qobject。

每个qobject都将指向各个子对象的指针存放在一个qobjectlist中。

<mark style="color:red;">怎么理解为什么不允许qobject对象之间进行复制？</mark>即使我们“克隆”一个人，但是也无法处理这个人所拥有的子孙问题。所有克隆对象是一个拥有不同身份、完全分离的、不同的对象。

如果我们把一个人堪称qobject，则每个object的身份都有所不同。

每个qobject父对象都会管理自己的子对象，调用qobject的析构函数自动销毁该对象的子对象。

子对象列表会在各个QObject对象之间建立一种双向的关联：1.· 每个父对象都知道它的子对象的地址。2.每个子对象都知道其父对象的地址。

给某个对象设置父对象，将会隐含地把此对象添加到父对象的子对象列表之中，但是如果更改的话就会把之前的删除在添加到新的父对象的对象列表中。

父对象与基类的比较：父—子关系是为了描述对象运行时的约束和**管理关系**。基类派生关系是编译时各个类进行判定的一种**静态关系**。

GUI)中的所有窗件都派生自 QWidge，而QWidget则从QObject派生而来。

<mark style="color:red;">假设要复制QObject,将会引起一些什么样的问题？</mark>子对象列表的浅复制(shallow copy)将无法工作，因为如果那样可行的话，则每个子对象都将会拥有两个父对象

通常而言，没有父对象的QObject应当在程序栈区(stack)中进行定义，而那些有父对象 的QObject则应当在堆区(heap)动态创建出来。这样可有助于确保发生正确的析构操作：位于栈区的对象是没有父对象的，在它超出作用域时就会被销毁掉

### 值和对象

C++类型可以分成两类：值(value)类型和对象(object)类型。

QVariant是一种特殊的联合体类型，可保存所有可复制的内置类型和编程人员定义的类型。QVariant已支持的诸如QList,Qimage,QString,QMap,等等，它们都支持隐式共享、 写时复制、引用计数。这意味着通过值对它们复制、传递和返回的代价要相对低一些。

从来没有令人信服的要在地区创建QList, QString, QHash, Qimage或者其他与 QVariant相关类型的理由，也不要那样做。

### 组合模式：父对象和子对象

组合模式(composite pattern)的意图是通过将部分—整体的层次结构表示成树状结构， 以便于使用较为简单（组件）的部分来创建出复杂（复合）的对象。

两个不同的类可以方便地描述上述两种角色：1.· 复合对象是包含可以包含子对象的类。2.组件对象是可以拥有一个父对象的类。Qt类都用到了组合模式：QObjec七，QWidget,QTreeWidgetI七em,QDomNode等等。

在任何基千树的结构体中都可以找到组合模式。一棵树中，最高层的（即 最为 “复合” 的）QObject对象（即树的根）将会有若干个子对象而没有父对象。

通过 QObject 的公有接口，可以构建一个类似千树的表达方式来描述这所大学的**组织结构**，然后编码实例化一个 OrgUnit 并调用 setParent( ）将其添加到合适的子对象列表中。

可以从任意特定的节点调用getSalary(）方法，返回的结果是以 此节点为根的子树所代表的大学中 相应部门的工资总和。 例如， 如果 ouptr 指向University, 那么ouptr->getSalary(）会返回整个大学的总工资；如果 ouptr 指向EnglishDpt,那么ouptr->getSalary(） 会返回英语系的总工资；

#### 查找子对象

每个QObject都可以有不限数量的QObject子对象。这些子对象的地址会存放在一个特殊的qobject指针容器内。QObject有一个成员函数，可以返回一个指向主对象中全部子对象的指针列表。函数原型：const QObjectList& QObject: :children{) const。

从 QObject 派生的任何对象都称为 QObject。也就是说心Object 指针也就可以保存一个派生对象的地址。

#### qobject的子对象管理

析构函数没有做任何显式的对象删除。它只是显示了即将要销毁的对象的名称（出千教学目的）。

当 growBunch( ）返回时，会销毁它的所有本地对象。

### QApplication和事件循环

在这些应用程序中， 对象之间频繁地通过间接对象相互发送消息。这就使得通过手动线性地跟踪整个代码变得异常复杂。

观察者模式：GUI视图需要对数据模型对象的状态变化做出响应，以便它们可以显示最新信息。当任意数据模型对象发生状态改变时，就需要一种间接的方式来提醒（并且可能向外 发送额外的信息）观察者。观察者就是一些正在监听（并且响应）状态变化事件的对象。使用这种消息传递机制的设计模式就称为观察者模式(Observerpattern,有时也称为 “发布－预定“ 模式，publish-subscribe pattern)。

这种模式有许多种不同的实现，但是它们都具有一些共同的特征：1.允许实体观察者类与实体主题类之间解耦。2.所采用的从主体向观察者发送信息的机制完全由主体的基类给定。

Qt的 QEvent类封装了底层事件的概念。QEvent对象可以由窗口系统创建以响应用户的动作。

事件循环是一个程序结构，它能够将事件划分优先级，**排队分配**给一些对象。

编写一 个基 于事件的应用程序就是**实现由函数组成的被动接口，**且这些函数仅仅在某些特定事件发生时才会得到调用， 如鼠标单击。

![](<.gitbook/assets/image (4).png>)在return语句中才出现对 QApplication::exec(）函数的调用。应用程序的整个工作部分开始于该函数的调用，终止于该函数的返回。

事件与信号和槽的比较：件可认为是低级消息，目标是某个特定的对象。信号可以认为是高级消息，很有可能会连接到许多槽上。只有在事件循环，特别是由 QApplication::exec(）进入的事件循环 中，信号才能发送到槽上。这是因为信号和槽在其外表之下是使用事件循环来传递消息的。

16章创建模式:使用事件循环的QT应用会首先实例化QApplication,创建另外一些对象，然后调用QApplication::exec()，启动事件循环。为了在程序的其他地方引用这个对象，可以使用qApp宏，它会返回一个指向这个单一 QApplication模式的指针芞16.1.4节中将更进一步探讨单一模式。

### 信号和槽

信号是在类定义中给出的类似于void函数声明的一种消息。它有参数列表却没有函数体。信号是一个类的接口的一部分。它看起来像函数，但不用同样的方式进行调用

槽通常是一个void **成员函数**。它可以像普通的成员函数一样进行调用，或者可以由QMetaObject系统进行间接调用。

一个对象的信号可以与一个或者多个对象的槽相连接，参数要兼容。

鼠标左键的释放事件，是畴单击中的最后一步，引起选中按钮窗件发射clicked(）信号。

如果有多个信号连接到同一个槽上且需要知道是哪一个QObject发射的信号，则可以在 该槽中调用sender(），它会返回 一个指向那个对象的指针。

Boost库也包含一种信号和槽的实现。



