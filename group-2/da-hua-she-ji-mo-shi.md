# 大话设计模式



![](<../.gitbook/assets/image (20) (1).png>)

###

### 装饰模式

#### 约会打扮

如果声明一个person类，那么需要非常多的成员函数；eg穿白t、黑t、打领带、白外套、西装.....

如果你要“超人”打扮，那么直接在person类中增加就行。可是这样就违背了开放-封闭原则。

然后你将这些服饰写成子类，这样子利用了抽象类。代码也确实做到了服饰类与人类的分离，可是还是有问题。

![](<../.gitbook/assets/image (23) (1).png>)

这样子做的话，如果要显示的要，需要一个一个的调用他们的show();

如果在内部直接组合一套然后在一个函数里。声明这个函数就行了，类似建造者模式。但是建造者模式需要内部稳定，而通过服装的组合可以有无数种！！

所以我们需要把所需的功能按正确的顺序串联起来进行控制。

#### 装饰模式结构图

装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

![](<../.gitbook/assets/image (11).png>)

每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中。意思就是你可以先穿外裤，在穿内裤，而不一定要先内后外。

#### 总结

装饰模式是**为已**有功能动态地添加更多功能的一种方式。

当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为。

在主类中加入新的方法和新的逻辑，从而增加了主类的复杂度，而这些新加入的东西仅仅是为了**满足一些特定情况下才会执行的特殊行为**。而装饰模式给这样的行为提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地，按顺序地使用装饰功能包装对象了。

该模式的优点总结下来就是，把类中的装饰功能从类中搬移去除，这样简化原有的类。这样做最大的好处就是有效地把类的核心职责和装饰功能区分开来。而且可以去除相关类中重复的装饰逻辑。

装饰模式的装饰顺序很重要，穿上西装在套上t恤实在不是好穿法。

### 代理模式

别人有不在身边男朋友了还叫你“代理男朋友”帮忙修电脑。

碰到心动的女孩却让朋友帮忙要微信。

#### 代码结构图&#x20;

![](<../.gitbook/assets/image (36).png>)

让追求者去实现送礼物的接口，让代理也去实现送礼物的接口。然后代理模式在送礼物的接口中调用追求者的接口。

#### 描述

代理模式：为其他对象提供一种代理以控制对这个对象的访问。

#### proxy结构图

![](<../.gitbook/assets/image (4) (1).png>)

subject就是送鲜花或者送礼物的接口，然后proxy和realsubject都继承这个接口，realsubject实现要送玫瑰花还是茉莉花，proxy接口调用realsubject实现好的成员函数。

#### 代理模式应用

1.远程代理，为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实。

2.虚拟代理，根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象。eg：打开一个很大的HTML网页，这时候可以很快的看到文字，图片却是没那么快可以看到。而那些没有打开的图片就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。

3.安全代理

代理模式其实就是在访问对象时引入一定程度的**间接性**。

### 工厂方法模式

#### 简单工厂模式实现

![](<../.gitbook/assets/image (26) (1).png>)

在工厂类中选择被选中的运算方法并且实例化该类。

#### 工厂方法模式实现

![](<../.gitbook/assets/image (7) (1).png>)

简单工厂中工厂类中的接口实现的是选择对应的方法，被选中的实例化。现在是纯虚函数接口被假发类工厂继承并且重载。

IFactory oper = new AddFactory();

#### 两者区别

如果加一个m的n次方的方法，那么简单工厂就要在加一个case来实现该功能。而对于工厂方法则是去增加一个功能类。

简单工厂模式的最大优点在千工厂类 中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。

**工厂方法模式**(FactoryMethod)，定义一个用千创建对象的接口，让子类决定实例化哪一 个类。工厂方法使一个类的实例化**延迟**到其子类。\[DP]

#### 工厂方法模式结构图

![](<../.gitbook/assets/image (47) (1).png>)![](<../.gitbook/assets/image (19).png>)

把工厂类抽象出一个接口，这个接口就是实例化一个产品类的。这样增加功能的时候就不需要更改原有的工厂类了。

相当于现在客户端要决定实例化哪一个工厂来实现运算类。简单工厂是在case中进行选择。一个要修改原有的类，一个是在客户端选择。

### 模板方法模式

#### 代码结构图

![](<../.gitbook/assets/image (17) (1).png>)

#### 模板方法模式

模板方法模式，定义一个操作中的算法骨架，而将一些步骤**延迟**到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

这边说的一些步骤指的就是上面所说的学生回答的答案！！算法骨架对应的就是考卷！！

又是延迟到子类，在工厂方法中也有延迟（使一个类的实例化**延迟**到其子类）。

#### 模板方法模式结构图

![](<../.gitbook/assets/image (37).png>)

#### 特点

模板方法模式是通过把不变行为搬移到继承类， 去除子类中的重复代码来体现它的优势。这样子学生就不用自己去手写一份卷子了，直接让老师发卷子。

当不变的和可变的行为在方法的子类实现中混合在一起的时 不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。

### 迪米特法则

**迪米特法则 (LoD)**， 如果两个类不必彼此直接通信， 那么这两个类就不应当发生直接的相互作用。 如果其中一个类衙要调用另一个类的某一个 方法的话， 可以通过第三者转发这个调用。

在类的结构设计上， 每一个类都应当尽量降低成员的访问权限，即包装好private。

迪米特法则其根本思想，是强调了类之间的松耦合。

耦合越弱，越有利于复合，一个处在弱耦合的类被修改， 不会对有关系的类造成波及。

### 外观模式

![](<../.gitbook/assets/image (16).png>)

空白菱形是**聚合关系，**实心菱形是**组合关系**

都了一个基金类，来负责外观的。

外观模式：为子系统中的一组接口提供一个**一致的界面**，此模式定义了一个高层接口，这个接口使得这一子系统更加**容易使用**。

#### 外观模式结构图

![](<../.gitbook/assets/image (48) (1).png>)

#### 何时使用外观模式

首先，在设计初期阶段，应该要有意识的将不同的两个层分离。比如经典的三层架构 ， 就需要考虑在数据访问层和业务逻辑层、 业务逻辑层和表示层的层与层之间建立外观 Facade, 这样可以为复杂的子系统提供一个简单的接口 ， 使得耦合大大降低。

其次， 在开发阶段子 统往往因为不断的重构演化而变得越来越复杂，会产生很多小类，增加外观Facade可以提供一个简单的接口，减少它们之间的依赖。

最后，在维护一个遗留的大型系统时， 可能这个系统已经非常难以维护和扩展了。但因为它包含非常重要的功能，新的需求开发必须要依赖千它。 此时用外观模式Facade也是非常合适的。为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰 简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。

![](<../.gitbook/assets/image (1).png>)

### 建造者模式

试想一个炒面没有放盐的话，这个炒面即使色香俱全，但是却是一个非常失败的“作品”。

可以肯德基成功的原因是什么？标准化，他不会忘记放盐巴，因为所有的流程都是标准的！

依赖倒转原则？抽象不应该依赖细节，细节应该依赖于抽象。

工作流程（肯德基的标准化）可以是一种抽象的流程，具体放什么配料、烤多久这些细节依赖这个抽象。

#### 建小人

![](<../.gitbook/assets/image (25).png>)   ![](<../.gitbook/assets/image (6) (1).png>)

有个人少画了腿，就跟没有炒面没有放盐巴一样的“作品”

可是有的时候我们经常会在编程的时候不注意，让他缺胳膊少腿。

#### 建造者模式

如果你需要将一个复杂对象的构建与它的表示分离，使得同样的 构建过程可以创建不同的表示的意图时，我们需要应用千一个设计模式--建造者(Builder)模式，又叫生成器模式。

建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。

如果我们用了建造者模式，那么用户就只需指定需要建造 的类型就可以得到它们，而具体建造的过程和细节就不需知道了。

**建造者模式(Builder)，将一个复杂对象的构建与它的表示分 离使得同样的构建过程可以创建不同的表示。**

#### 代码结构图

![](<../.gitbook/assets/image (30) (1).png>)

定义一个抽象的建造人的类（PersonBuilder），不让任何人遗忘当中的任何一步，如果继承类没有重载这个方法，编译器是不会让它通过的。

指挥者（Director）类，用它来控制建造过程，也用它来隔离用于于建造过程的关联。类的构造用户告诉指挥者，我需要什么样的小人。类中的成员函数是用来根据用户的选择建造小人的。

#### 建造模式结构图

![](<../.gitbook/assets/image (35) (1).png>)

Builder是什么？是为创建一个Product对象的各个部件指定的抽象接口。

ConcreteBullder是什么呢？它是具体建造者， 实现Builder接口 ， 构造和装配各个部件。

Product就是那些具体的 小人 ，产品角色。

Director是什么？它是构建一个使用Builder接口的对象。

建造者模式是在当创建**复杂对象**的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。

### 观察者模式

上班的时候偷偷看股票，可是老板可能一不小心来了，所以要在老板旁边安排一个卧底。

#### 双耦合的代码

卧底需要知道哪些人偷偷看股票，这样子才能够通知他们。所以要创建“看股票的同事”类。

而“看股票的同事”需要收到卧底的通知，所以也需要创建卧底类。

这样子的代码是相互耦合的，而且如果有人偷看NBA的画，那么就要更改卧底的代码了。这样违背了开放-封闭原则，修改原有代码说明设计不够好。也违背了依赖倒转原则，我们应该让程序都依赖抽象，而不是相互依赖。

#### 解耦

抽象出一个观察者，让看股票和看NBA的同事继承并且重载通知的方法。

而卧底代码部分就可以将具体的同事，改为“抽象的观察者”。针对抽象编程，减少了与具体类的耦合。

还可以继续改进！！抽象通知者的接口，这样具体类就可以是卧底，也可以是公司的前台，前台和老板的司机都可以进行通知。

#### 代码结构图

![](<../.gitbook/assets/image (45) (1).png>)

#### 观察者模式结构图

观察者模式又叫做发布-订阅模式。

观察者模式定义了一种**一对多**的依赖关系， 让多个观察者对象同时监听某一个主题对象。 这个主题对象在状态发生变化时， 会通知所有观察者对象， 使它们能够自动更新自己。

![](<../.gitbook/assets/image (46) (1).png>)

Subject类提供可以增加删除观察者对象。

Observer类， 抽象观察者， 为所有的具体观察者定义一个接口， 在得到主题的通知时更新自己。这个接口叫做更新接口。

ConcreteSubject类， 叫做具体主题或具体通知者， 将有关状态存入具体现察者对象；在具体主题的内部状态改变时， 给所有登记过的观察者**发出通知**。

#### 观察者模式特点

观察者模式动机：将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。

当一个对象的改变需要同时改变其他对象的时候，使用观察者模式。

总的来讲， 观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象， 而不是依赖千具体。从而使得各自的变化都不会影响另一边的变化。这是依赖倒转最佳体现。

#### 观察者模式的不足

vscode中点击运行时很多画面都进行了变更，实际上是在通知相关的控件产生变化， 但它们是不可能用接口的方式来实现观察者模式的。

尽管已经用了依赖倒转原则，但是＇抽象通知者＇还是依赖＇抽象观察 者，也就是说，万一没有了抽象观察者这样的接口，我这通知的功能就完不成了。

#### 事件委托实现

声明一个委托，EventHandler（事件处理程序），无参数，无返回值。

public event EventHandler Update;**//声明一事件Update,类型为委托EventHandler**

将看股票的关闭股票程序方法和看nba的关闭nba直播方法挂钩在老板的更新上，也就是将两不同类的不同方法委托给 “老板” 类的 “更新” 了。

#### 事件委托说明

&#x20;委托就是一种引用方法的类型。 一旦为委托分配了方法， 委托将与该方法具有完全相同的行为。 委托方法的使用可以像其他任何方法一样， 具有参数和返回值。 委托可以看作是对函数的抽象， 是函数的 ＇ 类 ＇， 委托的实例将代表一个具体的函数。

delegate void EventHandler 0;'可以理解为声明了一个特殊的 类 。而'public event EventHandler Update;'可以理解为声明了一个 类 的变量。

一旦为委托分配了方法， 委托将与该方法具有完全相 同的行为。 而且， 一个委托可以搭载多个方法， 所有方法被依次唤起。 更重要的是， 它可以使得委托对 象所搭载的方法井不需要属于同一个类。

但委托也是有前提的， 那就是委托对象所搭载的所有方法必须具有相同的原形和形式， 也就是拥 有相同的参数列表和返回值类型。





















