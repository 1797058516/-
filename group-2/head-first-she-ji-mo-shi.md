# Head First设计模式

##

## 设计模式入门

使用模式最好的方式是：把模式装进脑子里🧠，然后在你的设计和已有的应用中，寻找何处可以使用它们。

设计一个鸭子基类，定义游泳，外观等成员函数。此时公司要求增加功能，让鸭子飞。如果直接增加成员函数fly。那么会有可怕的事情发生。一个橡皮鸭子在屏幕飞来飞去。

因为对代码的局部修改，影响的层面不只是局部的。此时体会到：当涉及维护时，为了复用目的而使闭维承， 结局并不完美。

#### 利用接口

![](<../.gitbook/assets/image (32).png>)

这样也是不好的主意，如果几十个子类稍微修改一下飞行的行为，那么会非常复杂。

#### 良好的OO设计原则

如果能有一种建立软件软件的方法，好让我们可以用一种对既有的代码影响最小的方式来修改软件，可以这样的话，我们可以花较少时间重做代码，而让程序员做更酷的事情。跟嵌入式一样，初始化一个硬件往往容易出现错误，并且繁琐。HAL库的出现让一些事情变得简单，但是却要付出一些成本。

#### 把问题归零

<mark style="color:red;">设计原则：找出应用中可能需要变化之处，把它独立出来，不要和那些不需要变化的代码混在一起。</mark>

把会变化的部介取出“ 并封装”起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。这个概念很简单，几乎是每个设计模式**背后的精神所在**🔑。这种好的设计结果就是**代码变化引起的不经意后果变少，系统变得更有**_**弹性**_。

#### 分开变化和不会变化的部分

我们知道Duck类内的fly(）和quack(）会随着鸭子的不同而改变。为了要把这两个行为从Duck类中分开，我们将把它们从Duck类 中取出来，建立一组新类来代表每个行为。

![](<../.gitbook/assets/image (38).png>)

#### 设计鸭子的行为

我们应该在鸭子类中包含设 “ 定行为的方法 ， 这样就可以在 运行时“ 动态地 ”改变“ 绿头 鸭的飞行行为。有了这些目标要实现， 接着看看第二个设计原则：<mark style="color:red;">针对接口编程，而不是针对实现编程</mark>。

所以这次鸭子类不会负责实现Flying与Quacking接口 ， 反而是由我们制造一组其他类专门实现FlyBehavior与QuackBehavior, 这 就称为 “行为＂类。

以前的做法是：行为来自 Duck超类的 具体实现， 或是继承某个接口井由子类自行实现而来。 这两种 做法都是依赖于 “实现“ ，我们被实现绑得死死的， 没办法更 改行为（除非写更多代码） 。

在我们的新设计中 ， 鸭千·的子类将使用接口（FlyBehavior与 QuackBehavior) 所表示的行为， 所以实际的 “实现“ 不会被绑 死在鸭子的子类中。 （换句话说， 特定的具体行为编写在实现了 Fly Behavior与QuakeBehavior的类中）

从现在升始， 鸭子的行 为将被放在分开的类中． 此类专门提供某行为搂 口的实现。这样， 鸭子类就不再需 雯知违行为的实现细节。

![](<../.gitbook/assets/image (2).png>)

**＂针对接口编程“真正的意思是“针对超类型编程”**

＂针对接U编程” ， 关键就在多 哉利用多态， 程序可以针对超类型编样 ， 执行时会根据实际状况执行到贞正的行为， 不会被绑死在超类型的行为上。

![](<../.gitbook/assets/image (15).png>)

＂针对实现编程” Dog d = new Dog(); d bark();

＂针对接口／超类型编程”Animal animal = new Dog(); animal.makeSound(）;

#### 实现鸭子的行为

![](<../.gitbook/assets/image (40).png>)

这样的设计．可以让飞行和呱呱叫的动作被其他的对象复用．因为这些行为已经与鸭子类无关了。 而我们可以新增一些行为．不会影响到既有的行 为类、也不会影响“使用”到飞行行为的鸭子类。

#### 整合鸭子的行为

关键在于，鸭子现在会将飞行和呱呱叫的动作委托(delegate)别人处理，而不是使用定义在Duck类（或子类）内的呱呱叫和飞行方法。

需要这样做，首先， 在Duck类中“ 加入两个实例变量” ， 分别为"fly Behavior" 与“ quack Behavior" , 声明为接口类型（而不是具体类实现类型） ， 每个鸭子对象都会**动态地设置**这些变量以在运行时引用正确的行为类型（例如：FlyWithWings 、 Squeak等） 。我们必须将Duck类与其所有子类中的fly(）与quack(）**删除**， 因为这些行为已经被**搬到**FlyBehavior与Quack Behavior类中了。 我们用两个**相似**的方法performFly(）和performQuack(）取代Duck类中的fly(）与 quack(） 。

![](<../.gitbook/assets/image (41).png>)

![](<../.gitbook/assets/image (9).png>)

因为quackBehavior的实例变量是一个接口类型，我们能够在运行时， 通过多态的魔力动态地给它指定不同的 QuickBchavior实现类。

#### 动态设定行为

在运行期间改变鸭子的行为。

#### “有一个”可能比“是一个”更好

has a的关系可能比 is-a的关系更好。之前effective中提到public继承中最重要的一句好就是is-a关系。

第三个设计原则：<mark style="color:red;">**多用组合，少用继承**</mark>

使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以“在运行时动态地改变行为＂，只要 组合的行为对象符合正确的接的标准即可。

借用继承好东西可以一： 再被利用，所以程序开发时间就会大幅减少。

其实软件完成后花的时间比软件完成之前花的时间多。我们总是需要花许多时间在系统的维护和变化上，比原先开发花的时间更多。

那么我们应该致力千提高可维护性和可扩展性上的复用程度。

### 策略模式

前面用的其实就是策略模式

策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

当你需要给朋友留下深刻的印象，或是想影响主管的决策的时候，请使用这个模式。

#### 餐厅无意间听到

![](<../.gitbook/assets/image (18).png>)![](<../.gitbook/assets/image (39).png>)

这两个人点的其实是一份单，可是alice说的话是flo的两倍。厨师听到这么长的话会很崩溃，变得不耐烦。

flo和厨师之间有”共享的词汇“，alice却不懂这些词汇。

设计模式让你和其他开发人员之间有了共享的词汇，一旦懂这些词汇，和其他开发人员之间的沟通就会很容易。

设计模式也可以把你的思想架构的层次提高到模式层面，而不是仅仅停留在琐碎的对象上。

#### 在办公室隔间无意听到

![](<../.gitbook/assets/image (33).png>)![](<../.gitbook/assets/image (21).png>)

### 共享词汇的威力

你使用模式和他人沟通时， 其实 ”不只是 “ 和他人共享 “行话” 而已。

共享的模式词汇 “威力强大” 。当你使用楼式名称和其 他开发人员或者开发团队沟通时，你们之间交流的不只 是模式名称 ， 而是一整套模式背后所象征的质呈、 特性、 约束。

模式能够让你用更少的词汇做更充分的沟通。当你用模 式描述的时候， 其他开发人员使很容易地知道你对设计 的想法。

将说话的方式保持在模式层次，可让你待在 “设计圈子“久一点。使用模式谈论软件系统，可以让你保持在 设计层次，不会被压低到对象与类这种琐碎的事情上面。

共享词汇可帮你的开发团队快速充电。对于设计模式有深入了解的团队，彼此之间对千设计的看法不容易产生误解。

共享词汇能帮助初级开发人员迅速成长。 初级开发人员 向有经验的开发人员看齐。 当高级开发人员使用设计模 式， 初级开发人员也会跟着学。把你的组织建立成一个 模式使用者的社区。

#### 如何使用设计模式

设计模式不会直接进入你的代码中，而是先进入你的大脑中。一旦你先在脑海中装入了很多关于模式的知识，就能够开始在新设计中采用它们。

设计模式告诉我们如何组织类和对象以解决某种问题。

面向对象的谬误：以为知道了OO基础概念（封装、抽象、继承多态），就能自动设计出弹性的、可复用的、可维护的系统。

构造OO系统的隐含经验收集出来从而整理出一群”设计模式“

#### 设计工具箱中的工具

OO基础：抽象、封装、多态、继承

OO原则：封装变化、多用组合，少用继承、针对接口编程，不针对实现编程

OO模式：策略模式

阅读这本书时，时时刻刻要思考着：<mark style="color:red;">**模式如何依赖基础和原则**</mark>。

## 观察者模式

大话设计模式那本看到这个模式有一点懵，看看这本书讲的角度能不能让我更好的理解。

有一个模式可以帮你的对象知悉现况，不会错过该对象感兴趣的事。对象甚至在运行时可决定是乔要继续被通知。

#### 气象监测应用的概括

如果我们选择接受这个项目， 我们的工作就是建立一个应用， 利用WeatherData对象取得数据， 并更新三个布告板： 目前状况（温度 、 湿度、 气压）、 气象统计和天气预报。

我们的工作是实现measurcmentsChanged(）， 好让它更新目前状况、 气象统计 天气预报的显示布告板。

一且WeatherData有新的测蜇， 这些布告必须马上更新。

#### 错误示范

在measurementsChanged()调用weatheidata的三个setxxx方法，以取得最近的测量值。这些setxxx()方法已经实现好。

![](<../.gitbook/assets/image (43).png>)

### 出版社+订阅者=观察者模式

如果你了解报纸的订阅是怎么回事，其实就知道观察者模式是怎么回事 只是名称不太一样 ： 出版者改称为 “主题” (Subject) ， 订阅者改称为 “观察者” (Observer)。

当主题有变更的时候观察者能够收到通知----出版社出新报纸的时候订阅者会收到最新的报纸

#### 定义观察者模式

观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

![](<../.gitbook/assets/image (5).png>)

观察者依赖于此主题，只要主题状态一有变化，观察者就会被通知。

#### UML图

![](<../.gitbook/assets/image (42).png>)

**这个一对多的关系有何关联？**利用观察者模式 主题是具有状态的对象， 并且可以控制这些状态． 也就是说，有 一 具有状态的主题 另一方面、 观察者使用这些状态， 虽然这些状态并不属于他们。 有 许多的观察者， 依赖主题来告诉他们状态何时改变了 个关系， “一个 主题对“多个”观察者的关系。

#### 松耦合的威力

当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。 观察者模式提供了一种对象设计，让主题和观察者之间松耦合。

设计原则：<mark style="color:red;">**为了交互对象之间的松耦合设计而努力**</mark>。

松耦合的设计之所以能让我们建立有弹性的00系统， 能够应对变化， 是因为对象之间的互相依赖降到了最低。

#### 气象站结构图

![](<../.gitbook/assets/image (8).png>)

**想想各个模块应该怎么实现**

#### 观察者不想每秒都接受信息

![](<../.gitbook/assets/image (34).png>)

sctChanged(）方法可以让你在更新观察者时，有更多的弹性，你可以更 适当地通知观察者。如果没有setChanged(）方法，我们的气象站测批是如此敏锐， ｝ 以致干温度计读数知十分之度就会更新。如果你希望一个月更新一次或者变化2度通知一次那么这个函数就很有必要。

## 装饰对象

本章可以称为“给爱用继承的人一个全新的设计眼界”。

一旦熟悉装饰的技巧，将能够在不修改任何底层代码的情况下，给我们的对象赋予新的职责。



这章看的很奇怪，我换大话设计模式看吧这章节先跳过了。

## 工厂模式：烘烤OO精华

除了使用new操作符之外，还有更多制造对象的方法。接下来也会认识到初始化经常会造成“耦合”问题，也会了解工厂模式如何从复杂的依赖中帮你脱困。

我们不应该针对实现编程，但是我们使用new的时候不正是在针对实现编程吗？

#### 当看到new时，就会想到“具体”

当使用 “new"时， 是在实例化一个具体类， 所以用的确实是实现， 而不是接口。而这样代码绑着具体类会导致代码更脆弱， 更缺乏弹性。这个在第一章我们就知道了。

而针对接口编程你会写出下面的代码：

![](<../.gitbook/assets/image (31).png>)

这样的代码一且有变化或扩展， 就必须重新打开这段 代码进行检查和修改。通常这样修改过的代码将造成部分系统 更难维护和更新， 而且也更容易犯错。

#### new有什么不对劲

在技术上 ， new没有错， 毕竟这是Java的基础部分。正的 犯人是我们的老朋友 ”改变” ， 以及它是如何影响new的使用的。

针对接口编程， 可以隔离掉以后系统可能发生的一大堆改变。如果代码是针对接口而写 ， 那么通过多态它可以与任何新类实现该接口 。

当代码使用大量的具体类时，等于是自找麻烦，因为一旦加入新的具体类，就必须改变代码。

#### 当增加更多的披萨类型

![](<../.gitbook/assets/image (29).png>)

当我们已经知道哪些会改变，哪些不会改变，就是使用封装的时候了。

#### 变化独立出来的对象称为“工厂”

这个对象只管如何创建披萨。如果任何对象想要创建披萨找它就对了。

工厂(factory)处理创建对象的细节。

现在orderPizza(）方法只关心从工厂得到了一个比萨，而这个比萨实现了Pizza接口，所以它可以调用prepare(）、bake(）、cut(）、 box(）来分别进行准备烘烤、切片、装盒。

#### 定义简单工厂

简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。

披萨店结构图：

![](<../.gitbook/assets/image (28).png>)

####



## 单件模式：独一无二的对象

用来创建独一无二的，只能有一个实例的对象的入场券。&#x20;

单件模式的类图可以说是所有模式的类图最简单的，它的类图只有一个类。&#x20;

有一些对象其实孜们只需要一个， 比方说：线程池 (threadpool) 、 缓存 (cache) 、对话框 、 处理偏好设筑和注册表 (reg闪ry) 的对象、 日志对象， 充当打印机、 显卡等设备的驱动程序的对象。

单件模式是经得起时间考验的方法， 可以**确保只有一个实例**会袚创建。 单件桢式也给了孜们一个全局的访问点 ， 和全局变盎一样方便 ， 又没有全局变益的缺点．

全局变量在程序一开始的时候就要创建好，浪费资源。而单例模式我们可以在需要的时候才创建对象。

#### 创建单件模式

将类的构造函数声明为私有的，这样子能够保证新建类的时候不会调用构造函数。可是构造函数私有了，那么怎么能够创建出来呢？这个就跟鸡下蛋，蛋生鸡一样。

所以我们需要在类中声明static方法（getintance();），还需要利用一个静态变量来记录Single类的唯一实例。,让getintance()实例化对象，并返回这个实例。

getintance()方法中，增加一个判断条件，如果静态变量single类是空的，那么就实例化对象。不空的话就不创建，这样的话能够保证在单线程中创建出唯一的对象。

如果我们不需要这个实例，它就永远不会产生。这就是“延迟实例化”。

#### &#x20;单例模式结构图

单列模式：确保只有一个类只有一个实例，并提供一个全局访问点。

![](<../.gitbook/assets/image (13).png>)

#### 多线程中的单例模式

![](<../.gitbook/assets/image (22).png>)

既然这样的话我们直接在getintstance()增加同步关键字，那么就可以解决了。

确实是可以解决，如果程序中没有经常访问这段代码不会有什么影响，如果经常访问的话，那么性能会受到非常大的影响。可能差几十倍！！。

#### 改善多线程中的单例

1.使用“急切”创建实例，而不用延迟实例化的做法。直接在静态初始化器中创建单例。

**2**.用双重检查加锁，在getinstance()中减少使用同步。

![](<../.gitbook/assets/image (12).png>)

第二种办法大大减少了getinstance()的耗时，因为没有过多的用到同步。



























####
