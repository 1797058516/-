# Head First设计模式

##

## 设计模式入门

使用模式最好的方式是：把模式装进脑子里🧠，然后在你的设计和已有的应用中，寻找何处可以使用它们。

设计一个鸭子基类，定义游泳，外观等成员函数。此时公司要求增加功能，让鸭子飞。如果直接增加成员函数fly。那么会有可怕的事情发生。一个橡皮鸭子在屏幕飞来飞去。

因为对代码的局部修改，影响的层面不只是局部的。此时体会到：当涉及维护时，为了复用目的而使闭维承， 结局并不完美。

#### 利用接口

![](<../.gitbook/assets/image (32) (1).png>)

这样也是不好的主意，如果几十个子类稍微修改一下飞行的行为，那么会非常复杂。

#### 良好的OO设计原则

如果能有一种建立软件软件的方法，好让我们可以用一种对既有的代码影响最小的方式来修改软件，可以这样的话，我们可以花较少时间重做代码，而让程序员做更酷的事情。跟嵌入式一样，初始化一个硬件往往容易出现错误，并且繁琐。HAL库的出现让一些事情变得简单，但是却要付出一些成本。

#### 把问题归零

<mark style="color:red;">设计原则：找出应用中可能需要变化之处，把它独立出来，不要和那些不需要变化的代码混在一起。</mark>

把会变化的部介取出“ 并封装”起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。这个概念很简单，几乎是每个设计模式**背后的精神所在**🔑。这种好的设计结果就是**代码变化引起的不经意后果变少，系统变得更有**_**弹性**_。

#### 分开变化和不会变化的部分

我们知道Duck类内的fly(）和quack(）会随着鸭子的不同而改变。为了要把这两个行为从Duck类中分开，我们将把它们从Duck类 中取出来，建立一组新类来代表每个行为。

![](<../.gitbook/assets/image (38) (1).png>)

#### 设计鸭子的行为

我们应该在鸭子类中包含设 “ 定行为的方法 ， 这样就可以在 运行时“ 动态地 ”改变“ 绿头 鸭的飞行行为。有了这些目标要实现， 接着看看第二个设计原则：<mark style="color:red;">针对接口编程，而不是针对实现编程</mark>。

所以这次鸭子类不会负责实现Flying与Quacking接口 ， 反而是由我们制造一组其他类专门实现FlyBehavior与QuackBehavior, 这 就称为 “行为＂类。

以前的做法是：行为来自 Duck超类的 具体实现， 或是继承某个接口井由子类自行实现而来。 这两种 做法都是依赖于 “实现“ ，我们被实现绑得死死的， 没办法更 改行为（除非写更多代码） 。

在我们的新设计中 ， 鸭千·的子类将使用接口（FlyBehavior与 QuackBehavior) 所表示的行为， 所以实际的 “实现“ 不会被绑 死在鸭子的子类中。 （换句话说， 特定的具体行为编写在实现了 Fly Behavior与QuakeBehavior的类中）

从现在升始， 鸭子的行 为将被放在分开的类中． 此类专门提供某行为搂 口的实现。这样， 鸭子类就不再需 雯知违行为的实现细节。

![](<../.gitbook/assets/image (2).png>)

**＂针对接口编程“真正的意思是“针对超类型编程”**

＂针对接U编程” ， 关键就在多 哉利用多态， 程序可以针对超类型编样 ， 执行时会根据实际状况执行到贞正的行为， 不会被绑死在超类型的行为上。

![](<../.gitbook/assets/image (15).png>)

＂针对实现编程” Dog d = new Dog(); d bark();

＂针对接口／超类型编程”Animal animal = new Dog(); animal.makeSound(）;

#### 实现鸭子的行为

![](<../.gitbook/assets/image (40) (1).png>)

这样的设计．可以让飞行和呱呱叫的动作被其他的对象复用．因为这些行为已经与鸭子类无关了。 而我们可以新增一些行为．不会影响到既有的行 为类、也不会影响“使用”到飞行行为的鸭子类。

#### 整合鸭子的行为

关键在于，鸭子现在会将飞行和呱呱叫的动作委托(delegate)别人处理，而不是使用定义在Duck类（或子类）内的呱呱叫和飞行方法。

需要这样做，首先， 在Duck类中“ 加入两个实例变量” ， 分别为"fly Behavior" 与“ quack Behavior" , 声明为接口类型（而不是具体类实现类型） ， 每个鸭子对象都会**动态地设置**这些变量以在运行时引用正确的行为类型（例如：FlyWithWings 、 Squeak等） 。我们必须将Duck类与其所有子类中的fly(）与quack(）**删除**， 因为这些行为已经被**搬到**FlyBehavior与Quack Behavior类中了。 我们用两个**相似**的方法performFly(）和performQuack(）取代Duck类中的fly(）与 quack(） 。

![](<../.gitbook/assets/image (41) (1).png>)

![](<../.gitbook/assets/image (9).png>)

因为quackBehavior的实例变量是一个接口类型，我们能够在运行时， 通过多态的魔力动态地给它指定不同的 QuickBchavior实现类。

#### 动态设定行为

在运行期间改变鸭子的行为。

#### “有一个”可能比“是一个”更好

has a的关系可能比 is-a的关系更好。之前effective中提到public继承中最重要的一句好就是is-a关系。

第三个设计原则：<mark style="color:red;">**多用组合，少用继承**</mark>

使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以“在运行时动态地改变行为＂，只要 组合的行为对象符合正确的接的标准即可。

借用继承好东西可以一： 再被利用，所以程序开发时间就会大幅减少。

其实软件完成后花的时间比软件完成之前花的时间多。我们总是需要花许多时间在系统的维护和变化上，比原先开发花的时间更多。

那么我们应该致力千提高可维护性和可扩展性上的复用程度。

### 策略模式

前面用的其实就是策略模式

策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

当你需要给朋友留下深刻的印象，或是想影响主管的决策的时候，请使用这个模式。

#### 餐厅无意间听到

![](<../.gitbook/assets/image (18).png>)![](<../.gitbook/assets/image (39).png>)

这两个人点的其实是一份单，可是alice说的话是flo的两倍。厨师听到这么长的话会很崩溃，变得不耐烦。

flo和厨师之间有”共享的词汇“，alice却不懂这些词汇。

设计模式让你和其他开发人员之间有了共享的词汇，一旦懂这些词汇，和其他开发人员之间的沟通就会很容易。

设计模式也可以把你的思想架构的层次提高到模式层面，而不是仅仅停留在琐碎的对象上。

#### 在办公室隔间无意听到

![](<../.gitbook/assets/image (33) (1).png>)![](<../.gitbook/assets/image (21) (1).png>)

### 共享词汇的威力

你使用模式和他人沟通时， 其实 ”不只是 “ 和他人共享 “行话” 而已。

共享的模式词汇 “威力强大” 。当你使用楼式名称和其 他开发人员或者开发团队沟通时，你们之间交流的不只 是模式名称 ， 而是一整套模式背后所象征的质呈、 特性、 约束。

模式能够让你用更少的词汇做更充分的沟通。当你用模 式描述的时候， 其他开发人员使很容易地知道你对设计 的想法。

将说话的方式保持在模式层次，可让你待在 “设计圈子“久一点。使用模式谈论软件系统，可以让你保持在 设计层次，不会被压低到对象与类这种琐碎的事情上面。

共享词汇可帮你的开发团队快速充电。对于设计模式有深入了解的团队，彼此之间对千设计的看法不容易产生误解。

共享词汇能帮助初级开发人员迅速成长。 初级开发人员 向有经验的开发人员看齐。 当高级开发人员使用设计模 式， 初级开发人员也会跟着学。把你的组织建立成一个 模式使用者的社区。

#### 如何使用设计模式

设计模式不会直接进入你的代码中，而是先进入你的大脑中。一旦你先在脑海中装入了很多关于模式的知识，就能够开始在新设计中采用它们。

设计模式告诉我们如何组织类和对象以解决某种问题。

面向对象的谬误：以为知道了OO基础概念（封装、抽象、继承多态），就能自动设计出弹性的、可复用的、可维护的系统。

构造OO系统的隐含经验收集出来从而整理出一群”设计模式“

#### 设计工具箱中的工具

OO基础：抽象、封装、多态、继承

OO原则：封装变化、多用组合，少用继承、针对接口编程，不针对实现编程

OO模式：策略模式

阅读这本书时，时时刻刻要思考着：<mark style="color:red;">**模式如何依赖基础和原则**</mark>。

## 观察者模式

大话设计模式那本看到这个模式有一点懵，看看这本书讲的角度能不能让我更好的理解。

有一个模式可以帮你的对象知悉现况，不会错过该对象感兴趣的事。对象甚至在运行时可决定是乔要继续被通知。

#### 气象监测应用的概括

如果我们选择接受这个项目， 我们的工作就是建立一个应用， 利用WeatherData对象取得数据， 并更新三个布告板： 目前状况（温度 、 湿度、 气压）、 气象统计和天气预报。

我们的工作是实现measurcmentsChanged(）， 好让它更新目前状况、 气象统计 天气预报的显示布告板。

一且WeatherData有新的测蜇， 这些布告必须马上更新。

#### 错误示范

在measurementsChanged()调用weatheidata的三个setxxx方法，以取得最近的测量值。这些setxxx()方法已经实现好。

![](<../.gitbook/assets/image (43) (1).png>)

### 出版社+订阅者=观察者模式

如果你了解报纸的订阅是怎么回事，其实就知道观察者模式是怎么回事 只是名称不太一样 ： 出版者改称为 “主题” (Subject) ， 订阅者改称为 “观察者” (Observer)。

当主题有变更的时候观察者能够收到通知----出版社出新报纸的时候订阅者会收到最新的报纸

#### 定义观察者模式

观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

![](<../.gitbook/assets/image (5) (1).png>)

观察者依赖于此主题，只要主题状态一有变化，观察者就会被通知。

#### UML图

![](<../.gitbook/assets/image (42) (1).png>)

**这个一对多的关系有何关联？**利用观察者模式 主题是具有状态的对象， 并且可以控制这些状态． 也就是说，有 一 具有状态的主题 另一方面、 观察者使用这些状态， 虽然这些状态并不属于他们。 有 许多的观察者， 依赖主题来告诉他们状态何时改变了 个关系， “一个 主题对“多个”观察者的关系。

#### 松耦合的威力

当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。 观察者模式提供了一种对象设计，让主题和观察者之间松耦合。

设计原则：<mark style="color:red;">**为了交互对象之间的松耦合设计而努力**</mark>。

松耦合的设计之所以能让我们建立有弹性的00系统， 能够应对变化， 是因为对象之间的互相依赖降到了最低。

#### 气象站结构图

![](<../.gitbook/assets/image (8).png>)

**想想各个模块应该怎么实现**

#### 观察者不想每秒都接受信息

![](<../.gitbook/assets/image (34) (1).png>)

sctChanged(）方法可以让你在更新观察者时，有更多的弹性，你可以更 适当地通知观察者。如果没有setChanged(）方法，我们的气象站测批是如此敏锐， ｝ 以致干温度计读数知十分之度就会更新。如果你希望一个月更新一次或者变化2度通知一次那么这个函数就很有必要。

## 装饰对象

本章可以称为“给爱用继承的人一个全新的设计眼界”。

一旦熟悉装饰的技巧，将能够在不修改任何底层代码的情况下，给我们的对象赋予新的职责。



这章看的很奇怪，我换大话设计模式看吧这章节先跳过了。

## 工厂模式：烘烤OO精华

除了使用new操作符之外，还有更多制造对象的方法。接下来也会认识到初始化经常会造成“耦合”问题，也会了解工厂模式如何从复杂的依赖中帮你脱困。

我们不应该针对实现编程，但是我们使用new的时候不正是在针对实现编程吗？

#### 当看到new时，就会想到“具体”

当使用 “new"时， 是在实例化一个具体类， 所以用的确实是实现， 而不是接口。而这样代码绑着具体类会导致代码更脆弱， 更缺乏弹性。这个在第一章我们就知道了。

而针对接口编程你会写出下面的代码：

![](<../.gitbook/assets/image (31) (1).png>)

这样的代码一且有变化或扩展， 就必须重新打开这段 代码进行检查和修改。通常这样修改过的代码将造成部分系统 更难维护和更新， 而且也更容易犯错。

#### new有什么不对劲

在技术上 ， new没有错， 毕竟这是Java的基础部分。正的 犯人是我们的老朋友 ”改变” ， 以及它是如何影响new的使用的。

针对接口编程， 可以隔离掉以后系统可能发生的一大堆改变。如果代码是针对接口而写 ， 那么通过多态它可以与任何新类实现该接口 。

当代码使用大量的具体类时，等于是自找麻烦，因为一旦加入新的具体类，就必须改变代码。

#### 当增加更多的披萨类型

![](<../.gitbook/assets/image (29) (1).png>)

当我们已经知道哪些会改变，哪些不会改变，就是使用封装的时候了。

#### 变化独立出来的对象称为“工厂”

这个对象只管如何创建披萨。如果任何对象想要创建披萨找它就对了。

工厂(factory)处理创建对象的细节。

现在orderPizza(）方法只关心从工厂得到了一个比萨，而这个比萨实现了Pizza接口，所以它可以调用prepare(）、bake(）、cut(）、 box(）来分别进行准备烘烤、切片、装盒。

#### 定义简单工厂

简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。

披萨店结构图：

![](<../.gitbook/assets/image (28) (1).png>)

####



## 单件模式：独一无二的对象

用来创建独一无二的，只能有一个实例的对象的入场券。&#x20;

单件模式的类图可以说是所有模式的类图最简单的，它的类图只有一个类。&#x20;

有一些对象其实孜们只需要一个， 比方说：线程池 (threadpool) 、 缓存 (cache) 、对话框 、 处理偏好设筑和注册表 (reg闪ry) 的对象、 日志对象， 充当打印机、 显卡等设备的驱动程序的对象。

单件模式是经得起时间考验的方法， 可以**确保只有一个实例**会袚创建。 单件桢式也给了孜们一个全局的访问点 ， 和全局变盎一样方便 ， 又没有全局变益的缺点．

全局变量在程序一开始的时候就要创建好，浪费资源。而单例模式我们可以在需要的时候才创建对象。

#### 创建单件模式

将类的构造函数声明为私有的，这样子能够保证新建类的时候不会调用构造函数。可是构造函数私有了，那么怎么能够创建出来呢？这个就跟鸡下蛋，蛋生鸡一样。

所以我们需要在类中声明static方法（getintance();），还需要利用一个静态变量来记录Single类的唯一实例。,让getintance()实例化对象，并返回这个实例。

getintance()方法中，增加一个判断条件，如果静态变量single类是空的，那么就实例化对象。不空的话就不创建，这样的话能够保证在单线程中创建出唯一的对象。

如果我们不需要这个实例，它就永远不会产生。这就是“延迟实例化”。

#### &#x20;单例模式结构图

单列模式：确保只有一个类只有一个实例，并提供一个全局访问点。

![](<../.gitbook/assets/image (13).png>)

#### 多线程中的单例模式

![](<../.gitbook/assets/image (22) (1).png>)

既然这样的话我们直接在getintstance()增加同步关键字，那么就可以解决了。

确实是可以解决，如果程序中没有经常访问这段代码不会有什么影响，如果经常访问的话，那么性能会受到非常大的影响。可能差几十倍！！。

#### 改善多线程中的单例

1.使用“急切”创建实例，而不用延迟实例化的做法。直接在静态初始化器中创建单例。

**2**.用双重检查加锁，在getinstance()中减少使用同步。

![](<../.gitbook/assets/image (12) (1).png>)

第二种办法大大减少了getinstance()的耗时，因为没有过多的用到同步。

## 命令模式：封装调用

通过封装调用我们可以把运算块包装成形。调用此运算的对象不需要关心事情是如何进行的，只要知道如何使用包装成形的方法来完成它就可以。

#### 遥控器

遥控器需要解读按钮是否按下，但是不需要知道这些家电自动化的细节，或者如何打开热水器。

命令模式可以将“动作的请求者”从“动作的执行者”对象中解耦。

利用命令对象，把请求（例如打开电灯）封装成一个特定对象。所以， 如果对每个按钮都存储一个命令对象， 那么当按钮被桉下的时候 ， 就可以请命令对象做相关的工作。 遥 控器并不需要知道工作内容是什么 ， 只要有个命令对象能和正确的对象沟通， 把事情做好就可以了 。 所以， 遥控器和电灯对象解耦了。

使用这个模式，我们能够创建一个API，将这些命令对象加载到按钮插槽 ， 让遥控器的代码尽批保持简单。而把家电自动化的工作和进行该丁作的对象一起封装在命令对象中。

#### 餐厅

想象一下餐厅的具体流程。顾客来了需要点单，然后服务员需要跟厨师说这位顾客点了什么。如果人很少厨师可能是可以记得住的，但是人多起来，厨师和服务员可能会混淆顾客的点单。如果我们利用一个命令对象让厨师和服务员之间进行解耦，那么就是一个不错的设计。而这个命令对象就是菜单。服务员只需要在菜单记下顾客点了什么，而厨师只要看菜单点了什么。他们两之间从来不需要沟通。

这个模型允许将“发出请求的对象”和“接受执行这些请求的对象”分隔开来。

#### 遥控器的简单测试

空

#### 定义命令模式

理解命令模式内的类和对象是如何互动的。

**命令模式：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式支持可撤销的操作。**

一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作和接收者包进对象中。这个对象只暴露出一个execute()方法，此方法被调用的时候，接收者会进行这些动作。从外面来看，其他对象不知迫究竞哪个接收者进行了哪些动作，只知道如果调用execute(）方法，请求的目的就能达到．

利用命令来参数化对象的一些例子。在简单遥控器中，我们先用一个“打开电灯”命令加载到按钮槽，稍后又将命令替换成为另一个“打开车库门”命令。遥控器插槽根本不在乎所拥有的是什么命令对象，只要该命令对象实现了Command接口就可以了。

#### 命令模式类图

![](<../.gitbook/assets/image (4).png>)

我们需要一个方法，将命令指定到插槽。如果插槽都具备开和关按钮，我们就用类似方式（数组），将命令指定给遥控器。

遥控器并不区分这些，遥控器按下按钮，调用对应命令对象的execute()方法除外，它什么都不知道。

#### 将命令指定到插槽

当按下按钮，相应命令对象的execute（）方法就会被调用，其结果就是接收者的动作被调用。

在遥控器中我们不想每次都检查是否某个插槽都加载了命令。之前的话我们需要if语句进行判断。为了避免问题，我们需要实现一个不做事情的命令，这样我们将每个插槽都预先指定成Nocommand对象，以便确定每个插槽永远都有命令对象。

![](<../.gitbook/assets/image (38).png>)![](<../.gitbook/assets/image (34).png>)![](<../.gitbook/assets/image (47).png>)

在很多设计模式中，都会看到空对象的使用。甚至有时候，空对象本身也被视为一种设计模式。

#### 撤销命令

如果按下按钮，那么上一个动作将被倒转。

所以该命令就必须提供和execute()方法相反的undo()方法，即必须现在Command接口加入undo()方法。

为了让遥控器能够追踪最后被按下的按钮是什么，我们需要加入一个新的实例变量吗，用来追踪最后被调用的命令。

#### 使用状态实现撤销

想要实现撤销的功能，需要记录一些状态。eg吊扇的中高低档的转速。

需要追踪吊扇的最后设置速度，如果undo方法被调用了，就要恢复成之前吊扇速度的设置值。

![](<../.gitbook/assets/image (12).png>)

#### 命令模式的更多用途：队列请求mingling

命令可以江运算快打包（一个接收者和一组动作），然后将它传来传去，就像是一般对象一样。

即使在命令对象被创建许久之后，运算依然可以被调用它甚至可以在不同的线程中被调用。利用这个他特性衍生出的应用：日程安排、线程池、工作队列等等。

工作队列：在队列的一端添加队列，在另一端则是线程。线程的工作就是从队列取出一个命令，调用它的execute()方法，等待这个调用完成，然后将此命令丢弃，再取出下一个命令......

工作队列和进行计算的对象之间完全是解耦的。工作队列对象不在乎到底做些什么，它们只知道取出命令对象，然后调用其execute()方法。

#### 更多用途：日志请求

某些应用需要我们将所有的动作都记录在日志中，并能在系统死机之后，五新调 用这些动作恢复到之前的状态。

通过在Command接口中新增两个方法store(）、load()命令模式 ， 就能够支持这一点。

并且我们需要用对象的持久化来实现这个方法，将历史记录储存在磁盘中。

![](<../.gitbook/assets/image (44).png>)

## 适配器模式与外观模式

还记得装饰着模式吗？我们将对象包装起来，赋予它们新的职责。而现在则是不同目的，包装某些对象让它们的接口看起来不像自己的而像别人的东西。

在现实中，适配器改变了插座的接口，以符合美式笔记本电脑的插座需求。有的适配器很简单只要改变插口的形状，但是有的适配器内部很复杂，需要改变电流符合装置的需求。

在OO中，适配器扮演的角色是：将一个接口转换成另一个接口，以符合客户的期望。

![](<../.gitbook/assets/image (48).png>)

如果它走起路来像只鸭子，叫起来像只鸭子，那么它可能是一只包装了鸭子适配器的火鸡。

现在，假设你缺鸭子对象，想用一些火鸡对象来冒充。 显而易见，因为火鸡的接口不同，所以我们不能公然拿来用。 那么，就写个适配器吧！

#### 定义适配器模式

**适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。**

这样可以让客户从实现接口解耦。如果过段时间之后，我们想改变接口，适配器可以将改变的部分封装起来，客户就不必为了应对不同的接口而每次跟着修改。

该模式充满良好OO设计原则：使用对象组合，以修改的接口包装适配者；这种做法还有额外的有点：被适配者的任何子类，都可以搭配着适配器使用。

请注意这个模式是如何把客户和接口绑定起来，而不是和实现绑定起来的。

#### 类适配器

这个需要多重继承才能够实现；

![](<../.gitbook/assets/image (27).png>)

只能够采用某个特定的被适配类。但是不需要重新实现整个被适配者。

#### 对象适配器

![](<../.gitbook/assets/image (31).png>)

因为使用组合，该模式不仅可以适配某个类，也可以适配该类的任何子类；

#### 将枚举适配到迭代器

![](<../.gitbook/assets/image (43).png>)

枚举不支持删除，因为枚举是一个只读接口。这样的话，适配器就无法实现一个实际功能的remove方法，智能抛出一个运行时异常。

![](<../.gitbook/assets/image (50).png>)

#### 外观模式

具有简化接口的目的。

![](<../.gitbook/assets/image (33).png>)

watchMovie，将子系统的组件整合成一个统一的接口了。

#### 定义外观模式

我们创建一个接口讲话而统一，用来包装子系统中一个或多个复杂的类；

外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

设计原则--<mark style="color:red;">**最少知识原则：只和你的密友谈话。**</mark>

这个原则告诉我们要减少对象之间的交互，只留下几个密友。

当我们在设计一个系统，不管是任何对象，都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。主要是提醒我们不要让太多的类耦合在一起，免得修改系统中一部分，会影响到其他部分。

## 模板方法模式：封装算法

茶和咖啡的制作流程非常的相式，可以说方法基本都是一样。都要想烧开水，用热水泡茶或咖啡，把饮料倒进杯子，加入适当的调料。

真正相同的是烧开水，和把饮料倒入杯子。另外两个步骤虽然有所不同，但是方法是相同的！！！

所以我们声明类时，类中的用热水泡茶或咖啡，和加入适当的调料两个方法必须声明为抽象，剩余的东西交给子类去做。prepareRecipe()需要被声明为final，因为我们不希望子类覆盖这个方法,prepareRecipe()是冲泡流程；

![](<../.gitbook/assets/image (30).png>)

#### 认识模板方法

![](<../.gitbook/assets/image (45).png>)

模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。

caffeinebeverage类主导一切，它拥有算法，而且保护这个算法。

对于子类来说caffeinebeverage类的存在可以将代码的复用最大化。

算法只存在于一个地方，所以容易修改。

这个模板方法提供了一个框架，可以让其他的咖啡因饮料插进来，新的咖啡因饮料只需要实现自己的方法就可以了。

caffeinebeverage类专注在算法本身，而由子类提供完整的实现。

#### 定义模板方法

**模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤**

这个模式是用来创建一个算法的模板的，模板就是一个方法。更具体的说，这个方法就是一组步骤，其中任何步骤都可以是抽象的，由子类负责实现。这样可以确保算法的结构保持不变，同时由子类提供部分实现。

记得不改变的步骤需要声明为final，这样的话，子类就无法覆盖他。改变的步骤要声明为抽象，这样子子类才可以重写这个步骤。

#### 对模板方法进行挂钩

钩子是一种被声明在抽象类中的方法，但是只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。

![](<../.gitbook/assets/image (6).png>)

#### 使用钩子

为了使用钩子，我们在子类中覆盖它。在这个例子中，钩子控制了咖啡因饮料是否执行某部分算法；

![](<../.gitbook/assets/image (42).png>)

这个很酷，钩子能够作为条件控制，影响抽象类中的算法流程。

&#x20;使用钩子的真正目的？钓子可以让子类实现算法中可选的部分，或者在钓子对于子类的实现并不重要的时候，子类的实现并不重要的时候，子类可以对此钩子置之不理。钩子的另一个用法，是让子类能够有机会对模板方法中某些即将发生的（或刚刚发生的）步骤作出反应。

每一个具体的子类必须定义所有的抽象方法，并为模板帆帆发算法中未定义步骤提供完整实现。

#### 好莱坞原则

<mark style="color:red;">**好莱坞原则：别调用（打电话给）我们， 我 们会调用（打电话给）你。**</mark>

好莱坞原则可以给我们一种防止 依赖腐败＂ 的方法。 当高层组件依赖低层组件， 而低层组件又依赖高层组件 ， 而高层组件又依赖边侧组件， 而边侧组件又依赖低层组件时， 依赖腐败就发生了。 在这种情况下 ， 没有人可以轻易地搞懂系统是如何设计的。

在好莱坞原则之下 ， 我们允许低层组件将自己挂钩到系统 上 但是**高层组件会决定什么时候和怎样使用**这些低层组件。换句话说，高层组件对待低层组件的方式是“别调用我们，我们会调用你”

#### 好莱坞原则和模板方法

好莱坞原则和模板方法之间的连接其实还算明显：当我们设计模板方法模式时，我们告诉子类不要调用我们，我们会调用你＂ 。怎样才能办到呢？

![](<../.gitbook/assets/image (21).png>)

好莱坞原则和依赖倒置原则之间的关系如何？

答：依赖倒置原则教我们尽量避免使用具体类，而多使用抽象。 而好莱坞原则是用在创建框架或组件上的一种技巧，好让低层组件能够被挂钓进计算中 ，而且又不会让高层组件依赖低层组件。 两者的目标都是在于斛耦 ， 但是依赖倒置原则更加注重如何在设计中避免依赖。

好莱坞原则教我们一个技巧，创建一个由弹性的设计允许低层组件结构能够互相操作，而又防止其他类太过依赖它们。

#### 模板方法和策略的比较

策略：我定义一个算法家族，并让这些算法可以互换。 正因为每一个算法都被封装起来了 ， 所以客户可以轻易地使用不同的算法。

模板方法:我的工作是要定义一个算法的大纲， 而由我的子类定义其中某些步骤的内容 这么一来， 我在算法中的个别步骤可以有不同的实现细节， 但是算法的结构依然维持不变。 不过你就不一样了， 似乎你必须放弃对算法的控制。

策略：我并不是使用继承进行算法的实现， 我是通过对象组合的方 式， 让客户可以选择算法实现。

模板方法：但是我对算法有更多的控制权， 而且不会重复代码。 事实上，除了极少的一部分之外， 我的算法的每一个部分都是相同的， 所以我的类比你的有效率得多。

策略：你或许更有效率一点（只是一点点） 也的确需要更少的对象。 和我所采用的委托模型比起来 ， 你也没那么复杂。 但是因为我使用对象组合， 所以我更有弹性。 利用我， 客户就可以在运行时改变他们的算法，而客户所需要做的， 只是改用不同的策赂对象罢了。

&#x20;模板方法：我可是最常被使用的模式。 为什么呢？因为我在超类中提供了一个基础的方法， 达到代码的复用， 并允许子类指定行为。

策略：你的依赖程度比我高，你必须依赖超类中的方法的实现， 因为这是你算法中的一部分。 但我就不同了， 我不依赖任何人，整个算法我自己搞定！

## 迭代器与组合模式

在本章中学习如何让客户遍历你的对象而又无法窥视你存储对象的方式；也将学习如何创建一些对象超集合，能够一口气就跳过某些让人生畏数据结构。还将学到一些关于对象职责的知识。











